# 定义
事务提供一种机制将一个活动涉及的所有操作纳入到一个不可分割的执行单元，组成事务的所有操作只有在所有操作均能正常执行的情况下方能提交，只要其中任一操作执行失败，都将导致整个事务的回滚。简单地说，事务提供一种“要么什么都不做，要么做全套（All or Nothing）”机制。
分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。
# 分布式事务产生原因
业务数据分散在多个地方，多个数据库中或者数据库和缓存中
# 分布式事务的基础
<a href ="https://github.com/longshengguoji/architecture/blob/master/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA.md">CAP 理论和BASE理论</a>
# 分布式事务解决方案
## 2PC
分为两个阶段：<br/>
第一阶段：事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交.<br/>
第二阶段：事务协调器要求每个数据库提交数据，或者回滚数据。<br/>

<img src="https://github.com/longshengguoji/architecture/blob/master/img/2pc.png"  alt="2pc流程图" />

优点：
* 实现成本低
* 各大主流数据库具有自己的实现
缺点：
* 单点问题:事务管理器在整个流程中扮演的角色很关键，如果其宕机，比如在第一阶段已经完成，在第二阶段正准备提交的时候事务管理器宕机，资源管理器就会一直阻塞，导致数据库无法使用。
* 同步阻塞:在准备就绪之后，资源管理器中的资源一直处于阻塞，直到提交完成，释放资源。
* 数据不一致:两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，假设协调者发出了事务commit的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了commit操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。
* 不适合长事务场景
## TCC
全称为：Try-Confirm-Cancel<br/>
TCC模型完全交由业务实现，每个子业务都需要实现Try-Confirm-Cancel接口，对业务侵入较大<br/>
Try:尝试执行业务，完成所有业务检查，预留必要的业务资源<br/>
Confirm:真正执行业务，不再做业务检查<br/>
Cancel:尝试Try阶段预留的业务资源

## 本地消息表
此方案的核心是将需要分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试。人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理。

<img src="https://github.com/longshengguoji/architecture/blob/master/img/%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E6%B5%81%E7%A8%8B.png" alt="本地消息表事务" />

对于本地消息队列来说核心是把大事务转变为小事务。还是举上面用100元去买一瓶水的例子。<br/>
1.当你扣钱的时候，你需要在你扣钱的服务器上新增加一个本地消息表，你需要把你扣钱和写入减去水的库存到本地消息表放入同一个事务(依靠数据库本地事务保证一致性。<br/>
2.这个时候有个定时任务去轮询这个本地事务表，把没有发送的消息，扔给商品库存服务器，叫他减去水的库存，到达商品服务器之后这个时候得先写入这个服务器的事务表，然后进行扣减，扣减成功后，更新事务表中的状态<br/>
3.商品服务器通过定时任务扫描消息表或者直接通知扣钱服务器，扣钱服务器本地消息表进行状态更新。<br/>
4.针对一些异常情况，定时扫描未成功处理的消息，进行重新发送，在商品服务器接到消息之后，首先判断是否是重复的，如果已经接收，在判断是否执行，如果执行在马上又进行通知事务，如果未执行，需要重新执行需要由业务保证幂等，也就是不会多扣一瓶水。<br/>
本地消息队列是BASE理论，是最终一致模型，适用于对一致性要求不高的。实现这个模型时需要注意重试的幂等。

## MQ事务
## saga模型
把一个分布式事务拆分为多个本地事务，每个本地事务都有相应的执行模块和补偿模块<br/>
当saga事务中任意一个本地事务出错时，可以通过调用相关的补偿方法恢复之前的事务，达到事务最终一致性
saga的执行顺序：<br/>
T1,T2,T3,T4,...,Tn
T1,T2,...Tm,Cm,...,C2,C1
saga恢复方式：<br/>
* 向后恢复：补偿所有已完成的事务，如果任一子事务失败
* 向前恢复：重试失败的事务，假设每个子事务最终都会成功
saga隔离性：本地事务之间没有隔离性，需要应用层加锁<br/>
