# 分布式锁
分布式锁本质上要实现的目标是在Redis里面占一个位置，当别的进程也要来占位置时，发现这个位置已经有人了，就只好放弃或者稍后重试。<br/>
占位置一般使用setnx(set if not exist)指令，只允许被一个客户端占坑。先来先占，用完了，再调用del指令释放茅坑。<br/>
``` 
setnx resource_name randomstring
业务操作
del  resource_name 
```
但是有一个问题，如果逻辑执行到中间出现异常了，可能会导致del指令没有被调用，这样会陷入死锁，锁永远得不到释放。<br/>
因此拿到所之后，会给锁加上一个过期时间。<br/>
```
setnx resource_name randomvalue
expire resource_name 5
业务操作
del  resource_name
```
这种方式还是有个问题，就是setnx和expire之间可能会出现程序执行失败，导致expire没有执行，也会造成死锁。<br/>
解决方法是:<br/>
```
set resource_name randomvalue ex 5 nx
业务操作
del  resource_name
```
# 超时问题
Redis的分布式锁不能解决超时问题，如果在加锁和释放锁直接的业务逻辑执行的时间太长，以至于超出了锁的超时限制，就会出现问题。因为这个时候锁过期了，第二个线程重新持有了这把锁，但是第一个线程业务逻辑执行完之后释放了第二个线程的锁，第三个线程会在第二个线程逻辑执行期间拿到了锁。<br/>
解决思路是：释放锁时先判断随机数是否一致，然后再删除key.
```
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```
# 可重入性
可重入性是指线程在持有锁的情况下再次请求加锁，如果一个锁支持同一个线程的多次加锁，那么这个锁就是可重入的。
# redis集群实现分布式锁
集群环境下的分布式锁要复杂一点，假设有如下场景：<br/>
> 客户端1从Master获取了锁<br/>
Master宕机了，存储锁的key还没有来得及同步到Slave上<br/>
Slave升级为Master<br/>
客户端2从新的Master获取到了对应同一个资源的锁<br/>
客户端1和客户端2同时持有了同一个资源的锁，锁不再具有安全性

这个问题使用RedLock算法来解决<br/>
算法思路为：<br/>
* 获取当前时间。
* 按顺序依次向N个Redis节点执行获取锁的操作。这个获取操作跟前面基于单Redis节点的获取锁的过程相同，包含随机字符串my_random_value，也包含过期时间(比如PX 30000，即锁的有效时间)。为了保证在某个Redis节点不可用的时候算法能够继续运行，这个获取锁的操作还有一个超时时间(time out)，它要远小于锁的有效时间（几十毫秒量级）。客户端在向某个Redis节点获取锁失败以后，应该立即尝试下一个Redis节点。
* 计算整个获取锁的过程总共消耗了多长时间，计算方法是用当前时间减去第1步记录的时间。如果客户端从大多数Redis节点（>= N/2+1）成功获取到了锁，并且获取锁总共消耗的时间没有超过锁的有效时间(lock validity time)，那么这时客户端才认为最终获取锁成功；否则，认为最终获取锁失败。
* 如果最终获取锁成功了，那么这个锁的有效时间应该重新计算，它等于最初的锁的有效时间减去第3步计算出来的获取锁消耗的时间。
如果最终获取锁失败了（可能由于获取到锁的Redis节点个数少于N/2+1，或者整个获取锁的过程消耗的时间超过了锁的最初有效时间），那么客户端应该立即向所有Redis节点发起释放锁的操作。
